#!/usr/bin/env python3
"""
PLL Clock Tuner (ncurses) for STM32H7 (calibrator750)

- Arrow keys:  ←/→ move between fields, ↑/↓ increment/decrement by step
- PageUp/PageDown: ×10 step
- +/- : increment/decrement by step
- f: toggle fractional-N enable (FRACDIV fixed to 8192 on H7)
- e: edit current field value by typing (clamped to valid ranges)
- r: reset to defaults (26 MHz TCXO, M=13, N=240, FRACN=6932, P=1, Q=10, R=2,
                       d1cpre=1, hpre=2, d1ppre=2, d2ppre1=2, d2ppre2=2, d3ppre=2)
- s: save current config to "pll_config.h"
- q: quit
- F: toggle family label (cosmetic)

Hard limits (STM32H7):
  * 1 ≤ M ≤ 63
  * 4 ≤ N ≤ 512
  * 0 ≤ FRACN ≤ 8191   (FRACDIV = 8192)
  * P: either 1, or an even value 2..128
  * 2 ≤ Q,R ≤ 128
  * d1cpre ∈ {1,2,4,8,16,64,128,256,512}
  * hpre   ∈ {1,2,4,8,16,64,128,256,512}
  * ppre   ∈ {1,2,4,8,16}

This tool does NOT touch hardware; it's just a calculator.
"""
import curses
import curses.ascii
from math import isfinite

# ---------- Helpers / constraints ----------
VALID_D1CPRE = [1, 2, 4, 8, 16, 64, 128, 256, 512]
VALID_HPRE   = [1, 2, 4, 8, 16, 64, 128, 256, 512]
VALID_PPRE   = [1, 2, 4, 8, 16]
FRACDIV_FIXED = 8192

# Chip family display label (cosmetic)
FAMILY_H750 = 0
FAMILY_H735 = 1
FAMILY_NAMES = {FAMILY_H750: "H750/H743 (RM0433)", FAMILY_H735: "H735 (RM0468)"}

# ---------- Model ----------
class Cfg:
    def __init__(self):
        self.family = FAMILY_H750
        self.reset()

    def reset(self):
        self.HSE = 26_000_000
        self.M = 13
        self.N = 240
        self.FRACN = 6932
        self.frac_en = False
        self.P = 1                  # 1 or even 2..128
        self.Q = 10
        self.R = 2
        self.d1cpre = 1
        self.hpre = 2
        self.d1ppre = 2
        self.d2ppre1 = 2
        self.d2ppre2 = 2
        self.d3ppre = 2

    def as_header(self):
        lines = [
            "#pragma once",
            "// Auto-generated by PLL Clock Tuner (ncurses)",
            f"#define HSE_HZ       {int(self.HSE)}",
            f"#define DIVM1        {int(self.M)}",
            f"#define N_INT        {int(self.N)}",
            f"#define FRACN        {int(self.FRACN)}",
            f"#define FRACDIV      {FRACDIV_FIXED}",
            f"#define FRAC_EN      {1 if self.frac_en else 0}",
            f"#define DIVP1        {int(self.P)}",
            f"#define DIVQ1        {int(self.Q)}",
            f"#define DIVR1        {int(self.R)}",
            f"#define D1CPRE_DIV   {int(self.d1cpre)}",
            f"#define HPRE_DIV     {int(self.hpre)}",
            f"#define D1PPRE_DIV   {int(self.d1ppre)}",
            f"#define D2PPRE1_DIV  {int(self.d2ppre1)}",
            f"#define D2PPRE2_DIV  {int(self.d2ppre2)}",
            f"#define D3PPRE_DIV   {int(self.d3ppre)}",
        ]
        return "\n".join(lines) + "\n"

    def compute(self):
        try:
            fin = self.HSE / self.M
            n_eff = self.N + (self.FRACN / FRACDIV_FIXED if self.frac_en else 0.0)
            vco = fin * n_eff
            p = vco / self.P
            q = vco / self.Q
            r = vco / self.R

            sys_ck = p
            cpu = sys_ck / self.d1cpre
            hclk = cpu / self.hpre

            # ---- Correct APB derivations for STM32H7 domains ----
            # D1: APB3 is derived from D1 HCLK (== hclk here)
            apb3 = hclk / self.d1ppre

            # D2: APB1/APB2 derived from D2 HCLK (== hclk)
            apb1 = hclk / self.d2ppre1
            apb2 = hclk / self.d2ppre2

            # D3: APB4 derived from D3 HCLK (== hclk)
            apb4 = hclk / self.d3ppre

            # Timers only on APB1/APB2; double when prescaler > 1
            tim1 = apb1 * (2 if self.d2ppre1 > 1 else 1)
            tim2 = apb2 * (2 if self.d2ppre2 > 1 else 1)

            return {
                'fin': fin, 'n_eff': n_eff, 'vco': vco,
                'p': p, 'q': q, 'r': r,
                'sys_ck': sys_ck, 'cpu': cpu, 'hclk': hclk,
                'apb1': apb1, 'apb2': apb2, 'apb3': apb3, 'apb4': apb4,
                'tim_apb1': tim1, 'tim_apb2': tim2,
            }
        except Exception:
            return None

# ---- Fields config (label, attr, step, allowed, is_int, special) ----
P_VALID = [1] + [v for v in range(2, 129) if v % 2 == 0]  # 1,2,4,6,...,128
FIELDS = [
    ("HSE [Hz]",  "HSE",      1000,   (1_000_000, 64_000_000), False, None),
    ("M",         "M",        1,      (1, 63),                  True,  None),
    ("N",         "N",        1,      (4, 512),                 True,  None),
    ("FRACN",     "FRACN",    1,      (0, 8191),                True,  None),
    ("P (1 or even)", "P",    1,      P_VALID,                  True,  'set'),
    ("Q",         "Q",        1,      (1, 128),                 True,  None),
    ("R",         "R",        1,      (1, 128),                 True,  None),
    ("d1cpre",    "d1cpre",   1,      VALID_D1CPRE,             True,  'set'),
    ("hpre",      "hpre",     1,      VALID_HPRE,               True,  'set'),
    ("d1ppre",    "d1ppre",   1,      VALID_PPRE,               True,  'set'),
    ("d2ppre1",   "d2ppre1",  1,      VALID_PPRE,               True,  'set'),
    ("d2ppre2",   "d2ppre2",  1,      VALID_PPRE,               True,  'set'),
    ("d3ppre",    "d3ppre",   1,      VALID_PPRE,               True,  'set'),
]

def required_size(cfg):
    """
    Return the minimum (height, width) needed to render the full TUI.
    This is conservative to avoid out-of-bounds writes.
    """
    # Layout constants from draw()
    col_r = 28
    field_lines = len(FIELDS)

    # Top help/header block (~3 lines) + "Frac" line (1)
    header_lines = 3
    frac_line = 1

    # Fields block = one line per field
    fields_block = field_lines

    # Spacer lines between sections
    spacers = 2

    # Computed clocks section:
    #   title (1) + 14 lines of values + a couple of hint lines
    comp_title = 1
    comp_values = 14
    comp_hints = 2
    comp_block = comp_title + comp_values + comp_hints

    min_h = 4 + fields_block + spacers + comp_block  # safe headroom
    # Width: labels up to col_r plus some room for values
    min_w = max(col_r + 26, 64)  # ~26 chars for numbers; floor at 64 cols
    return min_h, min_w

def draw_small_window(stdscr, need_h, need_w):
    stdscr.clear()
    h, w = stdscr.getmaxyx()
    msgs = [
        "Window too small for PLL Clock Tuner",
        f"Need at least {need_w}×{need_h}, current is {w}×{h}.",
        "Resize your terminal and try again.",
        "Press q to quit.",
    ]
    # Center messages (best effort; avoid out-of-bounds)
    start_row = max(0, (h - len(msgs)) // 2)
    for i, m in enumerate(msgs):
        x = max(0, (w - len(m)) // 2)
        if start_row + i < h:
            try:
                stdscr.addstr(start_row + i, x, m, curses.A_BOLD if i == 0 else 0)
            except curses.error:
                pass
    stdscr.refresh()

HELP_TEXT = """
Keys:  ←/→ select  ↑/↓ change  PgUp/PgDn ×10  +/- step  f frac on/off  e edit  r reset  s save  q quit  F family
Constraints: FRACDIV=8192; P ∈ {1 or even 2..128}; Q/R ≥ 2; M[1..63], N[4..512], FRACN[0..8191].
"""

# ---------- UI ----------
def hz_fmt(x):
    if not isfinite(x):
        return "nan"
    units = ["Hz","kHz","MHz","GHz"]
    v = float(x)
    i = 0
    while v >= 1000.0 and i < len(units)-1:
        v /= 1000.0
        i += 1
    return f"{v:,.6f} {units[i]}".replace(",", "_")

def draw(stdscr, cfg, sel):
    stdscr.clear()
    stdscr.addstr(0, 2, "STM32H7 PLL Clock Tuner (calibrator750)", curses.A_BOLD)
    stdscr.addstr(1, 2, HELP_TEXT.strip())
    stdscr.addstr(2, 2, f"Frac-N: {'ON' if cfg.frac_en else 'OFF'}  (toggle: f)   FRACDIV: {FRACDIV_FIXED}   Family: {FAMILY_NAMES[cfg.family]} (F)")

    row = 4
    col_l = 2
    col_r = 28
    for i,(label, attr, step, allowed, is_int, special) in enumerate(FIELDS):
        val = getattr(cfg, attr)
        flag = curses.A_REVERSE if i == sel else curses.A_NORMAL
        stdscr.addstr(row+i, col_l, f"{label:>16}:")
        stdscr.addstr(row+i, col_r, f"{val}", flag)

    comp = cfg.compute()
    row2 = row + len(FIELDS) + 2
    if comp:
        lines = [
            ("fin", comp['fin']),
            ("N_eff", comp['n_eff']),
            ("VCO", comp['vco']),
            ("PLL1P (SYSCLK)", comp['p']),
            ("PLL1Q", comp['q']),
            ("PLL1R", comp['r']),
            ("CPU clk", comp['cpu']),
            ("AHB (HCLK)", comp['hclk']),
            ("APB1", comp['apb1']),
            ("APB2", comp['apb2']),
            ("APB3", comp['apb3']),
            ("APB4", comp['apb4']),
            ("TIM on APB1", comp['tim_apb1']),
            ("TIM on APB2", comp['tim_apb2']),
        ]
        stdscr.addstr(row2, 2, "Computed clocks:", curses.A_BOLD)
        for j,(k,v) in enumerate(lines):
            stdscr.addstr(row2+1+j, 4, f"{k:>14}: {hz_fmt(v)}")

        fin = comp['fin']
        hint_row = row2 + 1 + len(lines) + 1
        if not (1.0e6 <= fin <= 16.0e6):
            stdscr.addstr(hint_row, 4, f"Note: fin={hz_fmt(fin)} outside 1–16 MHz typical PLL input range.", curses.A_DIM)
            hint_row += 1
        stdscr.addstr(hint_row, 4, "P rule: 1 or even (2..128).", curses.A_DIM)
    else:
        stdscr.addstr(row2, 2, "(invalid parameters)", curses.A_BOLD)

    stdscr.refresh()

def coerce_allowed(value, allowed):
    if isinstance(allowed, tuple):
        lo, hi = allowed
        if value < lo: return lo
        if value > hi: return hi
        return value
    else:
        vals = list(allowed)
        # pick nearest
        nearest = min(vals, key=lambda x: abs(x - value))
        return nearest

def normalize_pdiv(value):
    v = int(round(value))
    if v <= 1:
        return 1
    if v % 2:
        v += 1 if v < 128 else -1
    if v < 2: v = 2
    if v > 128: v = 128
    return v

def normalize_field(attr, value, allowed, special):
    if special == 'pdiv':
        return normalize_pdiv(value)
    v = coerce_allowed(int(value) if isinstance(value, float) else value, allowed)
    return v

def edit_value(stdscr, cfg, field_idx):
    label, attr, step, allowed, is_int, special = FIELDS[field_idx]
    curses.echo()
    h, w = stdscr.getmaxyx()
    stdscr.addstr(h-2, 2, " " * (w-4))
    stdscr.addstr(h-2, 2, f"Enter {label}:")
    stdscr.refresh()
    s = stdscr.getstr(h-2, 2+len(f"Enter {label}:")).decode('utf-8').strip()
    curses.noecho()
    try:
        val = int(s) if is_int else float(s)
        val = normalize_field(attr, val, allowed, special)
        setattr(cfg, attr, val)
    except ValueError:
        pass

def step_for(field_idx, mult10=False):
    label, attr, step, allowed, is_int, special = FIELDS[field_idx]
    return step * (10 if mult10 else 1)

def adjust(cfg, field_idx, delta, mult10=False):
    label, attr, step, allowed, is_int, special = FIELDS[field_idx]
    cur = getattr(cfg, attr)
    if special == 'pdiv':
        jump = (10 if mult10 else 1) * (1 if delta>0 else -1)
        new = normalize_pdiv(cur + jump)
    elif isinstance(allowed, tuple):
        s = step_for(field_idx, mult10)
        new = cur + (s if delta>0 else -s)
        new = normalize_field(attr, new, allowed, special)
    else:
        vals = list(allowed)
        try:
            i = vals.index(cur)
        except ValueError:
            i = 0
        jump = 10 if mult10 else 1
        i = (i + (jump if delta>0 else -jump)) % len(vals)
        new = vals[i]
    setattr(cfg, attr, int(new) if is_int else new)

def save_header(cfg):
    with open("pll_config.h", "w") as f:
        f.write(cfg.as_header())

def draw(stdscr, cfg, sel):
    stdscr.clear()
    h, w = stdscr.getmaxyx()

    need_h, need_w = required_size(cfg)
    if h < need_h or w < need_w:
        # Render a small message instead of crashing
        draw_small_window(stdscr, need_h, need_w)
        return False  # indicate we did not draw the full UI

    stdscr.addstr(0, 2, "STM32H7 PLL Clock Tuner (calibrator750)", curses.A_BOLD)
    stdscr.addstr(1, 2, HELP_TEXT.strip())
    stdscr.addstr(2, 2, f"Frac-N: {'ON' if cfg.frac_en else 'OFF'}  (toggle: f)   FRACDIV: {FRACDIV_FIXED}   Family: {FAMILY_NAMES[cfg.family]} (F)")

    row = 4
    col_l = 2
    col_r = 28
    for i,(label, attr, step, allowed, is_int, special) in enumerate(FIELDS):
        val = getattr(cfg, attr)
        flag = curses.A_REVERSE if i == sel else curses.A_NORMAL
        stdscr.addstr(row+i, col_l, f"{label:>16}:")
        stdscr.addstr(row+i, col_r, f"{val}", flag)

    comp = cfg.compute()
    row2 = row + len(FIELDS) + 2
    if comp:
        lines = [
            ("fin", comp['fin']),
            ("N_eff", comp['n_eff']),
            ("VCO", comp['vco']),
            ("PLL1P (SYSCLK)", comp['p']),
            ("PLL1Q", comp['q']),
            ("PLL1R", comp['r']),
            ("CPU clk", comp['cpu']),
            ("AHB (HCLK)", comp['hclk']),
            ("APB1", comp['apb1']),
            ("APB2", comp['apb2']),
            ("APB3", comp['apb3']),
            ("APB4", comp['apb4']),
            ("TIM on APB1", comp['tim_apb1']),
            ("TIM on APB2", comp['tim_apb2']),
        ]
        stdscr.addstr(row2, 2, "Computed clocks:", curses.A_BOLD)
        for j,(k,v) in enumerate(lines):
            stdscr.addstr(row2+1+j, 4, f"{k:>14}: {hz_fmt(v)}")

        fin = comp['fin']
        hint_row = row2 + 1 + len(lines) + 1
        if not (1.0e6 <= fin <= 16.0e6):
            stdscr.addstr(hint_row, 4, f"Note: fin={hz_fmt(fin)} outside 1–16 MHz typical PLL input range.", curses.A_DIM)
            hint_row += 1
        stdscr.addstr(hint_row, 4, "P rule: 1 or even (2..128).", curses.A_DIM)
    else:
        stdscr.addstr(row2, 2, "(invalid parameters)", curses.A_BOLD)

    stdscr.refresh()
    return True  # full UI drawn

def main(stdscr):
    curses.curs_set(0)
    stdscr.nodelay(False)
    stdscr.keypad(True)

    cfg = Cfg()
    sel = 0
    draw(stdscr, cfg, sel)

    while True:
        ch = stdscr.getch()
        if ch in (ord('q'), ord('Q')):
            break
        elif ch == curses.KEY_LEFT:
            sel = (sel - 1) % len(FIELDS)
        elif ch == curses.KEY_RIGHT:
            sel = (sel + 1) % len(FIELDS)
        elif ch in (curses.KEY_UP, ord('+')):
            adjust(cfg, sel, +1, mult10=False)
        elif ch in (curses.KEY_DOWN, ord('-')):
            adjust(cfg, sel, -1, mult10=False)
        elif ch == curses.KEY_PPAGE:
            adjust(cfg, sel, +1, mult10=True)
        elif ch == curses.KEY_NPAGE:
            adjust(cfg, sel, -1, mult10=True)
        elif ch in (ord('f'),):
            cfg.frac_en = not cfg.frac_en
        elif ch in (ord('e'),):
            edit_value(stdscr, cfg, sel)
        elif ch in (ord('r'),):
            cfg.reset()
        elif ch in (ord('s'),):
            save_header(cfg)
        elif ch in (ord('F'),):
            cfg.family = FAMILY_H735 if cfg.family == FAMILY_H750 else FAMILY_H750
        draw(stdscr, cfg, sel)

if __name__ == '__main__':
    curses.wrapper(main)

