#!/usr/bin/env python3
"""
TIMx PWM Tuner (ncurses) for STM32H7 (calibrator750)

- Arrow keys:  ←/→ move between fields, ↑/↓ increment/decrement by step
- PageUp/PageDown: ×10 step
- +/- : increment/decrement by step
- e: edit current field value by typing (clamped to valid ranges)
- d: toggle 50% duty lock (CCR = (ARR+1)/2 with even period)
- c: toggle center-aligned mode (CMS≠0 → freq halves)
- a: AUTO-FIT PSC/ARR to Goal_f [Hz] (prefers exact; else nearest)
- r: reset to defaults (APB=120 MHz, PPRE=2 → f_tim=240 MHz;
                       PSC=0, ARR=3, CCR3=2, CCR4=2, 50% lock ON, edge-aligned)
- s: save current config to "tim_config.h"
- t: toggle timer width (16/32-bit ARR)
- q: quit

Hard limits (STM32H7):
  * PSC ∈ [0..65535]
  * ARR ∈ [1..65535] for 16-bit timers (TIM3/4/12/13/14), [1..0xFFFFFFFF] for 32-bit (TIM2/5)
  * CCRx ∈ [0..ARR]
  * PPRE ∈ {1,2,4,8,16} (timer clock doubles when PPRE>1)
Notes:
  * f_tim = (PPRE == 1) ? APB : 2*APB
  * Edge-aligned: f_pwm = f_tim / ((PSC+1)*(ARR+1))
  * Center-aligned: f_pwm = f_tim / (2*(PSC+1)*(ARR+1))
  * Exact 50% requires (ARR+1) even and CCR=(ARR+1)/2
"""

import curses
import curses.ascii
from math import isfinite

PPRE_VALID = [1, 2, 4, 8, 16]
TIMER_BITS = [16, 32]  # 16-bit (TIM3/4/12/13/14), 32-bit (TIM2/5)

class Cfg:
    def __init__(self):
        self.reset()

    def reset(self):
        # Clocking
        self.APB_HZ = 120_000_000     # APB1 on your setup
        self.PPRE = 2                 # APB prescaler divisor
        self.bits = 32                # TIM2/5 by default
        # Timer core
        self.PSC = 2
        self.ARR = 9
        self.CCR3 = 5
        self.CCR4 = 5
        # Behavior
        self.lock50 = True            # keep CCR=(ARR+1)/2 with even period
        self.center = False           # edge-aligned default
        # Goal
        self.Goal_f = 8_000_000       # 8 MHz (exact with ARR=9 on 240MHz)
        # Internal sanity
        self._clamp_all()

    # ---------- math ----------
    def f_tim(self):
        return self.APB_HZ if self.PPRE == 1 else 2 * self.APB_HZ

    def arr_max(self):
        return 0xFFFF if self.bits == 16 else 0xFFFFFFFF

    def period_N(self):
        return self.ARR + 1

    def pwm_freq(self):
        denom = (self.PSC + 1) * (self.period_N())
        if denom <= 0:
            return float('nan')
        f = self.f_tim() / denom
        if self.center:
            f *= 0.5
        return f

    def duty(self, ccr):
        N = self.period_N()
        if N <= 0: return float('nan')
        return (ccr / N) if N else float('nan')

    def compute(self):
        tim = self.f_tim()
        f = self.pwm_freq()
        return {
            'f_tim': tim,
            'f_pwm': f,
            'duty3': self.duty(self.CCR3),
            'duty4': self.duty(self.CCR4),
            'N': self.period_N(),
            'center': self.center,
            'ppre': self.PPRE,
        }

    # ---------- helpers ----------
    def _enforce_lock50(self):
        if not self.lock50: return
        N = self.period_N()
        # Make N even if needed
        if N < 2:
            N = 2
            self.ARR = N - 1
        if N & 1:   # odd -> adjust ARR up by 1, else down if saturated
            if self.ARR < self.arr_max():
                self.ARR += 1
                N += 1
            else:
                if self.ARR > 1:
                    self.ARR -= 1
                    N -= 1
        # Set CCRs to exact 50%
        N = self.period_N()
        self.CCR3 = N // 2
        self.CCR4 = N // 2

    def _clamp_all(self):
        # clamp ranges
        self.PPRE = min(PPRE_VALID, key=lambda x: abs(x - self.PPRE))
        self.bits = 16 if self.bits <= 16 else 32
        self.PSC = max(0, min(65535, int(self.PSC)))
        self.ARR = max(1, min(self.arr_max(), int(self.ARR)))
        self.CCR3 = max(0, min(self.ARR, int(self.CCR3)))
        self.CCR4 = max(0, min(self.ARR, int(self.CCR4)))
        self.Goal_f = max(1, int(self.Goal_f))
        self._enforce_lock50()

    def as_header(self):
        comp = self.compute()
        lines = [
            "#pragma once",
            "// Auto-generated by TIMx PWM Tuner (ncurses)",
            f"#define APB_HZ        {int(self.APB_HZ)}",
            f"#define PPRE_DIV      {int(self.PPRE)}",
            f"#define TIM_BITS      {int(self.bits)}",
            "",
            f"#define TIM_PSC       {int(self.PSC)}",
            f"#define TIM_ARR       {int(self.ARR)}",
            f"#define TIM_CCR3      {int(self.CCR3)}",
            f"#define TIM_CCR4      {int(self.CCR4)}",
            f"#define TIM_CENTER    {1 if self.center else 0}  // 0=edge, 1=center",
            f"#define TIM_LOCK50    {1 if self.lock50 else 0}",
            "",
            f"// Derived (for info): f_tim={int(comp['f_tim'])} Hz, f_pwm≈{int(comp['f_pwm'])} Hz",
            f"// N=ARR+1={int(comp['N'])}, duty3≈{comp['duty3']:.6f}, duty4≈{comp['duty4']:.6f}",
        ]
        return "\n".join(lines) + "\n"

    # AUTO-FIT: prefer exact, else nearest
    def autofit(self):
        f_goal = self.Goal_f
        if not isfinite(f_goal) or f_goal <= 0:
            return False, "Bad goal frequency"
        tim = self.f_tim()
        # Effective period factor for center
        center_factor = 2 if self.center else 1

        # Try EXACT first
        if (tim % (f_goal * center_factor)) == 0:
            K = tim // (f_goal * center_factor)  # K = (PSC+1)*N
            # scan small PSCs first
            for psc in range(0, 65536):
                denom = psc + 1
                if K % denom:
                    continue
                N = K // denom
                if N < 2:
                    continue
                if self.lock50 and (N & 1):
                    continue  # need even N for exact 50%
                arr = N - 1
                if arr > self.arr_max():
                    continue
                # found exact
                self.PSC = psc
                self.ARR = arr
                self._clamp_all()
                return True, "EXACT"
        # Nearest
        best = None
        best_err = 1e9
        # Keep PSC small for resolution/speed
        psc_limit = 4095
        for psc in range(0, min(65535, psc_limit)+1):
            denom = psc + 1
            Nideal = tim / (denom * f_goal * center_factor)
            if Nideal < 2:
                continue
            # Round to nearest valid N; if lock50 then restrict to even
            N0 = int(Nideal + 0.5)
            cand = [N0, N0-1, N0+1]
            for N in cand:
                if N < 2:
                    continue
                if self.lock50 and (N & 1):
                    continue
                arr = N - 1
                if arr > self.arr_max():
                    continue
                f_pwm = tim / (denom * N) / center_factor
                err = abs(f_pwm - f_goal) / f_goal
                if err < best_err:
                    best_err = err
                    best = (psc, arr, f_pwm)
        if best:
            self.PSC, self.ARR, f_pwm = best
            self._clamp_all()
            return True, f"NEAREST (err={best_err*100:.4f}%)"
        return False, "No fit"

# ---------- UI ----------
HELP = """
Keys:  ←/→ select  ↑/↓ change  PgUp/PgDn ×10  +/- step
       e edit  d lock50  c center  a auto-fit  r reset  s save  t timer width  q quit
"""

FIELDS = [
    # label, attr, step,   allowed,                      is_int, kind
    ("APB [Hz]",   "APB_HZ",  1000,   (1_000_000, 600_000_000), True,  None),
    ("PPRE",       "PPRE",    1,      PPRE_VALID,               True,  'set'),
    ("Timer bits", "bits",    16,     TIMER_BITS,               True,  'set'),
    ("PSC",        "PSC",     1,      (0, 65535),               True,  None),
    ("ARR",        "ARR",     1,      ("ARR",),                 True,  None),  # custom clamp
    ("CCR3",       "CCR3",    1,      ("CCR",3),                True,  None),
    ("CCR4",       "CCR4",    1,      ("CCR",4),                True,  None),
    ("Goal_f [Hz]","Goal_f",  1000,   (1, 600_000_000),         True,  None),
]

def hz_fmt(x):
    if not isfinite(x): return "nan"
    units = ["Hz","kHz","MHz","GHz"]
    v = float(x); i = 0
    while v >= 1000.0 and i < len(units)-1:
        v /= 1000.0; i += 1
    return f"{v:,.6f} {units[i]}".replace(",", "_")

def pct_fmt(x):
    if not isfinite(x): return "nan"
    return f"{x*100:6.3f}%"

def draw(stdscr, cfg, sel, status=""):
    stdscr.clear()
    stdscr.addstr(0, 2, "STM32H7 TIMx PWM Tuner (calibrator750)", curses.A_BOLD)
    stdscr.addstr(1, 2, HELP.strip())

    row = 3; col_l = 2; col_r = 24
    for i,(label, attr, step, allowed, is_int, kind) in enumerate(FIELDS):
        val = getattr(cfg, attr)
        flag = curses.A_REVERSE if i == sel else curses.A_NORMAL
        stdscr.addstr(row+i, col_l, f"{label:>14}:")
        stdscr.addstr(row+i, col_r, f"{val}", flag)

    comp = cfg.compute()
    row2 = row + len(FIELDS) + 1
    stdscr.addstr(row2, 2, "Computed:", curses.A_BOLD)
    stdscr.addstr(row2+1,  4, f"f_tim      : {hz_fmt(comp['f_tim'])}   (PPRE={comp['ppre']}, double={'YES' if cfg.PPRE>1 else 'NO'})")
    stdscr.addstr(row2+2,  4, f"mode       : {'CENTER' if comp['center'] else 'EDGE'}")
    stdscr.addstr(row2+3,  4, f"N=ARR+1    : {int(comp['N'])} {'(even)' if (comp['N']%2==0) else '(odd)'}")
    stdscr.addstr(row2+4,  4, f"f_pwm      : {hz_fmt(comp['f_pwm'])}")
    stdscr.addstr(row2+5,  4, f"CH3 duty   : {pct_fmt(comp['duty3'])}")
    stdscr.addstr(row2+6,  4, f"CH4 duty   : {pct_fmt(comp['duty4'])}")
    stdscr.addstr(row2+7,  4, f"lock 50%   : {'ON' if cfg.lock50 else 'OFF'}")

    if cfg.lock50 and (comp['N'] % 2):
        stdscr.addstr(row2+8, 4, "Note: 50% requires even N=(ARR+1). Adjusting ARR when needed.", curses.A_DIM)

    if status:
        stdscr.addstr(row2+10, 2, status)

    stdscr.refresh()

def coerce_allowed(cfg, attr, value, allowed):
    if isinstance(allowed, tuple):
        # special placeholders
        if allowed and allowed[0] == "ARR":
            lo, hi = 1, cfg.arr_max()
            v = max(lo, min(hi, int(value)))
            return v
        if allowed and allowed[0] == "CCR":
            ch = allowed[1]  # unused; both CCR clamp to ARR
            hi = cfg.ARR
            v = max(0, min(hi, int(value)))
            return v
        lo, hi = allowed
        return max(lo, min(hi, int(value)))
    else:
        vals = list(allowed)
        # choose nearest set value
        return min(vals, key=lambda x: abs(x - int(value)))

def edit_value(stdscr, cfg, field_idx):
    label, attr, step, allowed, is_int, kind = FIELDS[field_idx]
    curses.echo()
    h, w = stdscr.getmaxyx()
    stdscr.addstr(h-2, 2, " " * (w-4))
    stdscr.addstr(h-2, 2, f"Enter {label}:")
    stdscr.refresh()
    s = stdscr.getstr(h-2, 2+len(f"Enter {label}:")).decode('utf-8').strip()
    curses.noecho()
    try:
        val = int(s)
        val = coerce_allowed(cfg, attr, val, allowed)
        setattr(cfg, attr, val)
        cfg._clamp_all()
    except ValueError:
        pass

def step_for(field_idx, mult10=False):
    label, attr, step, allowed, is_int, kind = FIELDS[field_idx]
    return step * (10 if mult10 else 1)

def adjust(cfg, field_idx, delta, mult10=False):
    label, attr, step, allowed, is_int, kind = FIELDS[field_idx]
    cur = getattr(cfg, attr)
    if kind == 'set':
        # rotate through allowed set
        vals = list(allowed)
        try:
            i = vals.index(cur)
        except ValueError:
            i = 0
        jump = 10 if mult10 else 1
        i = (i + (jump if delta>0 else -jump)) % len(vals)
        new = vals[i]
        setattr(cfg, attr, new)
        cfg._clamp_all()
        return

    s = step_for(field_idx, mult10)
    new = cur + (s if delta>0 else -s)
    new = coerce_allowed(cfg, attr, new, allowed)
    setattr(cfg, attr, new)
    cfg._clamp_all()

def save_header(cfg):
    with open("tim_config.h", "w") as f:
        f.write(cfg.as_header())

def main(stdscr):
    curses.curs_set(0)
    stdscr.nodelay(False)
    stdscr.keypad(True)

    cfg = Cfg()
    sel = 0
    status = ""
    draw(stdscr, cfg, sel, status)

    while True:
        ch = stdscr.getch()
        if ch in (ord('q'), ord('Q')):
            break
        elif ch == curses.KEY_LEFT:
            sel = (sel - 1) % len(FIELDS)
        elif ch == curses.KEY_RIGHT:
            sel = (sel + 1) % len(FIELDS)
        elif ch in (curses.KEY_UP, ord('+')):
            adjust(cfg, sel, +1, mult10=False)
        elif ch in (curses.KEY_DOWN, ord('-')):
            adjust(cfg, sel, -1, mult10=False)
        elif ch == curses.KEY_PPAGE:
            adjust(cfg, sel, +1, mult10=True)
        elif ch == curses.KEY_NPAGE:
            adjust(cfg, sel, -1, mult10=True)
        elif ch in (ord('e'),):
            edit_value(stdscr, cfg, sel)
        elif ch in (ord('d'),):
            cfg.lock50 = not cfg.lock50
            cfg._clamp_all()
        elif ch in (ord('c'),):
            cfg.center = not cfg.center
            cfg._clamp_all()
        elif ch in (ord('t'),):
            cfg.bits = 16 if cfg.bits == 32 else 32
            cfg._clamp_all()
        elif ch in (ord('a'),):
            ok, msg = cfg.autofit()
            status = f"AUTO-FIT: {msg}" if ok else f"AUTO-FIT failed: {msg}"
        elif ch in (ord('r'),):
            cfg.reset(); status = "Reset."
        elif ch in (ord('s'),):
            try:
                save_header(cfg)
                status = 'Saved to "tim_config.h".'
            except Exception as e:
                status = f"Save failed: {e}"
        else:
            # Unhandled key: no status change
            pass

        draw(stdscr, cfg, sel, status)

if __name__ == '__main__':
    curses.wrapper(main)

